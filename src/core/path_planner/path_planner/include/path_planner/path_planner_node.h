#ifndef RMP_PATH_PLANNER_PATH_PLANNER_NODE_H_
#define RMP_PATH_PLANNER_PATH_PLANNER_NODE_H_

#include <ros/ros.h>
#include <nav_core/base_global_planner.h>
#include <geometry_msgs/PoseStamped.h>
#include <nav_msgs/GetPlan.h>

#include "common/geometry/point.h"
#include "path_planner/path_planner.h"

namespace rmp
{
namespace path_planner
{
class PathPlannerNode : public nav_core::BaseGlobalPlanner
{
public:
  /**
   * @brief Construct a new Path Planner object
   */
  PathPlannerNode();

  /**
   * @brief Construct a new Path Planner object
   * @param name        planner name
   * @param costmap_ros the cost map to use for assigning costs to trajectories
   */
  PathPlannerNode(std::string name, costmap_2d::Costmap2DROS* costmap_ros);

  /**
   * @brief Destroy the Path Planner object
   */
  ~PathPlannerNode() = default;

  /**
   * @brief Planner initialization
   * @param name       planner name
   * @param costmapRos costmap ROS wrapper
   */
  void initialize(std::string name, costmap_2d::Costmap2DROS* costmapRos);

  /**
   * @brief Planner initialization
   * @param name planner name
   */
  void initialize(std::string name);

  /**
   * @brief Plan a path given start and goal in world map
   * @param start start in world map
   * @param goal  goal in world map
   * @param plan  plan
   * @return true if find a path successfully, else false
   */
  bool makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal,
                std::vector<geometry_msgs::PoseStamped>& plan);

  /**
   * @brief Plan a path given start and goal in world map
   * @param start     start in world map
   * @param goal      goal in world map
   * @param plan      plan
   * @param tolerance error tolerance
   * @return true if find a path successfully, else false
   */
  bool makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal, double tolerance,
                std::vector<geometry_msgs::PoseStamped>& plan);
  /**
   * @brief Regeister planning service
   * @param req  request from client
   * @param resp response from server
   */
  bool makePlanService(nav_msgs::GetPlan::Request& req, nav_msgs::GetPlan::Response& resp);

protected:
  /**
   * @brief Calculate plan from planning path
   * @param path path generated by global planner
   * @param plan plan transfromed from path, i.e. [start, ..., goal]
   * @return bool true if successful, else false
   */
  bool _getPlanFromPath(PathPlanner::Points3d& path, std::vector<geometry_msgs::PoseStamped>& plan);

protected:
  enum PLANNER_TYPE
  {
    GRAPH_PLANNER = 0,
    SAMPLE_PLANNER = 1,
    EVOLUTION_PLANNER = 2,
  };

protected:
  bool initialized_;                        // initialization flag
  costmap_2d::Costmap2DROS* costmap_ros_;   // costmap(ROS wrapper)
  std::string frame_id_;                    // costmap frame ID
  std::string planner_name_;                // planner name
  PLANNER_TYPE planner_type_;               // planner type
  std::string smoother_name_;               // smoother name
  std::shared_ptr<PathPlanner> g_planner_;  // global graph planner
  ros::Publisher plan_pub_;                 // path planning publisher
  ros::Publisher expand_pub_;               // nodes explorer publisher
  ros::Publisher tree_pub_;                 // random search tree publisher
  ros::Publisher particles_pub_;            // evolutionary particles publisher
  ros::ServiceServer make_plan_srv_;        // planning service

private:
  bool is_outline_;   // whether outline the boudary of map
  bool is_expand_;    // whether publish expand map or not
  double tolerance_;  // tolerance
  double factor_;     // obstacle inflation factor
};
}  // namespace path_planner
}  // namespace rmp
#endif